[
        {
          "id": "blog-2016-09-26-amazon-ses-with-rails",
          "title": "Using Amazon SES with Rails",
          "collection": {
            "label": "posts",
            "name": "Posts"
          },
          "categories": "blog",
          "tags": "",
          "url": "/blog/2016/09/26/amazon-ses-with-rails/",
          "content": "Like many developers, we made the decision to rely on a third party service to send our emails. We have been using SendGrid for a long time now, and have so far been letting the odd delay or two go because of the overall reliability. We are now working at a much larger scale, so not only do we need a more timely service, we also need to be able to load balance our traffic across a variety of providers to ensure we have a plan B if one of our providers goes down. This became a priority after the more recent outages experienced by SendGrid, and in our travels around the web we came across Amazon SES. There are some quirks getting this up and running, so we thought we’d share what we’ve learned here at Alphasights.\n\nThe Setup\nAmazon SES provides an SMTP endpoint, so we can rely on the regular ActionMailer setup, example as follows:\nRails.application.configure do\n  config.action_mailer.smtp_settings = {\n    user_name: ENV['SMTP_USER_NAME'],\n    password: ENV['SMTP_PASSWORD'],\n    address: ENV['SMTP_ADDRESS'],\n    domain:  ENV['SMTP_DOMAIN'],\n    port: ENV['SMTP_PORT'],\n    authentication: ENV['SMTP_AUTHENTICATION'],\n    enable_starttls_auto: ENV['SMTP_ENABLE_STARTTLS_AUTO'] == 'true'\n}\nend\n\nNote: “enable_starttls_auto” must be set to true to work with Amazon SES\n\nGenerating the SMTP credentials is pretty straight forward. You can find the link below, and the documentation is pretty clear so I won’t repeat it here.\n\n\n  \n    \n      \n    \n  \n  \n    \n      https://console.aws.amazon.com/ses/home?region=us-east-1#smtp-settings\n    \n  \n\n\nIf you are familiar with spam filters, there is no avoiding the management of SPF records. We didn’t want to undo all the good work we had done over the years of optimizing these settings to ensure that we don’t end up in our clients’ spam filters, which is a much harder challenge than you would think! So we followed the recommendation by amazon to use a sub-domain that had a DNS entry similar to:\n\nv=spf1 include:amazonses.com -all\n\nWithout going into too much detail, this adds amazon’s subnet to the list of allowed hosts that are allowed to send emails on your behalf. By using a subdomain, you also avoid the “mailed by amazonses.com” tag on email clients like gmail. To verify your DNS settings were set correctly you can use:\n\ndig my-subdomain.my-domain.com TXT\nexpected result:\nmy-subdomain.example.com. 300 IN TXT \"v=spf1 include:amazonses.com ~all\"\n\n\nYou can also look directly at amazon’s SPF entry, and see what permissions you are providing by executing:\ndig amazonses.com TXT\n\nAmazon provides a helpful UI which you can use to make sure everything works, and the DNS settings are as expected which we recommend using before adding the complication of your own app.\n\nThe Quirks\nAfter we had set everything up, for some reason our emails were being flagged as spam by gmail. We went around in circles, from comparing SPF records to checking our email headers to see if Amazon was somehow changing them. The problem turned out to be related to this requirement:\n\n\n  Before you can send an email using Amazon SES, you must verify each email address (or the domain of the email address) that you will use as a “From”, “Source”, “Sender”, or “Return-Path” address to prove that you own it. If your account is still in the Amazon SES sandbox, you also need to verify any email addresses that you send emails to except for email addresses provided by the Amazon SES mailbox simulator. You can verify an email address or domain by using the Amazon SES console or by using the Amazon SES API.\n\n\nThe above is quite clear, but they leave something out. If you have verified an email address, but also whitelist a whole domain, the two verifications conflict. In our case, real_email@my-domain.com was a verified email address, but was going to spam. If we used a fake email address like fake@my-domain.com we would get through without any problems. This is because the verification of an email takes precedence over a domain level verification. In our case that meant we had a different rule set for real_email@my-domain.com. Which means that we had setup all our DNS, DKIM and SPF settings for our email to come from our subdomain, but the verified email was using the default settings of sending the email from amazonses.com.\n\nThe Fail over\n\nNow we have reliably used both services, switching between them is as simple as:\n\nheroku config:set \nSMTP_ADDRESS=amazon.com\nSMTP_AUTHENTICATION=login \nSMTP_DOMAIN=my-domain.com\nSMTP_PASSWORD=my-pass\nSMTP_PORT=587\nSMTP_ENABLE_STARTTLS_AUTO=true \n-a myapp\n\n\nWe are now ready to quickly alternate between the two if there’s a problem or if we decide that one provider is too expensive. The reason we had not switched providers sooner was the assumption that the complexity was too high for the value. We assumed another API would have to be implemented, or the dependency on another library like aws-ses would be required. Under the pressure of trying to put out the fire that is Sengrid we were forced to look at other alternatives, and how to quickly get them up and running. In this scenario SMTP, although ugly, really shines through. Understanding SPF really wasn’t that bad and is well documented.\n\nWhat’s next?\nFrom the above you may have guessed we are currently using Amazon SES on some of our Rails apps but not all. We want to get to a place where one Rails app can use multiple providers, and load balance the email traffic across them all. This has some challenges including being able to swap provider without rebooting the app, therefore avoiding the use of “Rails.application.configure”. We also need to come up with a way of weighting the providers based on known performance, which may be coming in a later blog post."
        },
        {
          "id": "blog-2014-11-12-using-lambdas-with-let-in-rspec",
          "title": "Using lambdas with let (in rspec)",
          "collection": {
            "label": "posts",
            "name": "Posts"
          },
          "categories": "blog",
          "tags": "",
          "url": "/blog/2014/11/12/using-lambdas-with-let-in-rspec/",
          "content": "As many of you already know, let has been a great improvement on declaring instance variables\nin our before :each blocks. Lazy loading on when it’s used while being kept in memory for the\nduration of the test. One way in which we use lets, for more complicated variable definitions, is to\nuse let, and provide it with arguments using a lambda:\n\nlet(:user) {\n    -&gt;(name, email) {\n      double(\"user\", user: email, email: email)\n    }\n  }\n\n\nYou can then easily setup users in your test:\n\ndescribe 'Given a user' do\n  context 'with internal address' do\n    it 'redirects to intranet' do\n      login_as user['Bob', 'bob@internal.com']\n      ...\n    end\n  end\n  context 'with external address' do\n    let(:staff_user) { user['Bob', 'bob@internal.com'] }\n    it 'redirects to external domain' do\n      login_as user['Pete', 'pete@gmail.com']\n      ...\n    end\n  end\nend"
        },
        {
          "id": "blog-2014-09-15-git-cheat-sheet",
          "title": "Git Cheat sheet",
          "collection": {
            "label": "posts",
            "name": "Posts"
          },
          "categories": "blog",
          "tags": "",
          "url": "/blog/2014/09/15/git-cheat-sheet/",
          "content": "Git commands that I always forget but find useful:\n\n# Recover a file:\ngit checkout &lt;previous-commit-hash&gt; &lt;file_path&gt;\n\n# Ignore changes to certain files:\ngit update-index --assume-unchanged config/database.yml\n\n# Take commit from another branch:\ngit cherry-pick &lt;commit reference&gt;\n\n# Delete multiple branches starting with some string:\ngit branch -D `git for-each-ref --format=\"%(refname:short)\" refs/heads/some_string\\*`\n\n# Delete all branches merged with master\ngit branch --merged | egrep -v '(^\\*|master)' | xargs git branch -d\n\n# List branches in order of which most recent commit\ngit for-each-ref --sort=-committerdate refs/heads/\n\n\nI tend to alias things so when on another machine it’s handy!"
        },
        {
          "id": "blog-2014-09-15-resizing-images-in-mavericks",
          "title": "Resizing images in Mavericks",
          "collection": {
            "label": "posts",
            "name": "Posts"
          },
          "categories": "blog",
          "tags": "",
          "url": "/blog/2014/09/15/resizing-images-in-mavericks/",
          "content": "After a search for batch resizing tools, which most require a bit of fiddling around with.\nI found a handy command line tool which comes with maverick, sips.\n\nsips -Z 1024 *.jpg\n\n\nIf you run the above in a directory of pictures, it will resize all pictures in the current directory.\nFor my needs, I passed -Z to keep the ratio, and a maximum height of 1024 pixels.\n\nAs always, make sure to keep the original in case you don’t like the results!"
        },
        {
          "id": "404",
          "title": "404 Not Found",
          "collection": {
            "label": "pages",
            "name": "Posts"
          },
          "categories": "",
          "tags": "",
          "url": "/404",
          "content": "Page not found :(\nThe requested page could not be found."
        },
        {
          "id": "500",
          "title": "500",
          "collection": {
            "label": "pages",
            "name": "Posts"
          },
          "categories": "",
          "tags": "",
          "url": "/500",
          "content": "500\n\nInternal Server Error :(\n\nThe requested page could not be delivered."
        },
        {
          "id": "about",
          "title": "About",
          "collection": {
            "label": "pages",
            "name": "Posts"
          },
          "categories": "",
          "tags": "",
          "url": "/about/",
          "content": "This is the basic Bridgetown site template. You can find out more info about customizing your Bridgetown site, as well as basic Bridgetown usage documentation at bridgetownrb.com\n\nYou can find the source code for Bridgetown at GitHub:\nbridgetownrb /\nbridgetown"
        },
        {
          "id": "bridgetown_quick_search-index.json",
          "title": "Index",
          "collection": {
            "label": "pages",
            "name": "Posts"
          },
          "categories": "",
          "tags": "",
          "url": "/bridgetown_quick_search/index.json",
          "content": "[\n  {%- assign looped = false %}\n  {%- assign documents = site.documents %}\n  {%- if site.content_engine == \"resource\" %}{% assign documents = site.resources %}{% endif %}\n  {%- for document in documents %}\n    {%- if document.title %}\n      {%- unless document.exclude_from_search or document.id == \"\" %}\n        {%- assign url = document.url %}\n        {%- if site.content_engine == \"resource\" %}{% assign url = document.relative_url %}{% endif %}\n        {%- if looped %},{% endif %}\n        {\n          \"id\": \"{{ url | slugify }}\",\n          \"title\": {{ document.title | jsonify }},\n          {%- if document.collection %}\n          \"collection\": {\n            \"label\": {{ document.collection.label | jsonify }},\n            \"name\": {{ document.collection.name | default: \"Posts\" | jsonify }}\n          },\n          {%- endif %}\n          \"categories\": {{ document.categories | join: \", \" | jsonify }},\n          \"tags\": {{ document.tags | join: \", \" | jsonify }},\n          \"url\": {{ url | jsonify }},\n          \"content\": {{ document.content | strip_html | replace_regex: \"[\\s/\\n]+\",\" \" | strip | jsonify }}\n        }\n        {%- assign looped = true %}\n      {%- endunless %}\n    {%- endif %}\n  {%- endfor %}\n  {%- for document in site.generated_pages %}\n    {%- if document.name contains \".md\" or document.name contains \".html\" %}\n      {%- if document.title %}\n        {%- unless document.exclude_from_search %}\n          {%- if looped %},{% endif %}\n          {\n            \"id\": \"{{ document.url | slugify }}\",\n            \"title\": {{ document.title | jsonify }},\n            \"categories\": {{ document.categories | join: \", \" | jsonify }},\n            \"tags\": {{ document.tags | join: \", \" | jsonify }},\n            \"url\": {{ document.url | jsonify }},\n            \"content\": {{ document.content | strip_html | replace_regex: \"[\\s/\\n]+\",\" \" | strip | jsonify }}\n          }\n        {%- endunless %}\n      {%- endif %}\n    {%- endif %}\n  {%- endfor %}\n]"
        },
        {
          "id": "",
          "title": "Abe Petrillo",
          "collection": {
            "label": "data",
            "name": "Posts"
          },
          "categories": "",
          "tags": "",
          "url": "",
          "content": ""
        }
]
